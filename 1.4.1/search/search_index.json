{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview # SmallRye Stork 1.4.1 is a service discovery and client-side load-balancing framework. The essence of distributed systems resides in the interaction between services . In modern architecture, you often have multiple instances of your service to share the load or improve the resilience by redundancy. But, how do you select the best instance of your service? That\u2019s where Stork helps. Stork is going to select the most appropriate instance. It offers: Extensible service discovery mechanisms Built-in support for Consul and Kubernetes Customizable client load-balancing strategies A programmatic API and a managed approach A Quarkus integration, but Stork can be used in any environment The problem # In distributed systems, applications typically need to call one another. In a monolithic application, components invoke one another through language-level method or procedure calls. In a traditional distributed system deployment, services run at fixed, well-known locations (schemes, hosts, and ports) and can call one another using HTTP/REST or some RPC mechanism. The service locations are often hardcoded in the application configuration. Nevertheless, a modern distributed system or microservice-based application typically runs in virtualized or containerized environments where the number of instances of a service and their locations change dynamically. IPs get randomly assigned, and instances can be created or destroyed at any time. With such dynamics, hard-coded locations are a dead-end. The solution # Stork handles the service lookup and selection. It proposes an extensible set of service discovery mechanisms and load-balancing strategies. What if the infrastructure provides such a feature? # Some infrastructure, such as Kubernetes, provides service discoveries and load-balancing features. However, these mechanisms often lack flexibility. You cannot influence the service instance selection, and the load-balancing strategy is generally a simple round-robin . Stork provides more flexibility in the service instance selection. For example, it can select the fastest instance (based on the previous calls) to improve the response time. However, if you don\u2019t need that flexibility, just use the infrastructure layer.","title":"Overview"},{"location":"#overview","text":"SmallRye Stork 1.4.1 is a service discovery and client-side load-balancing framework. The essence of distributed systems resides in the interaction between services . In modern architecture, you often have multiple instances of your service to share the load or improve the resilience by redundancy. But, how do you select the best instance of your service? That\u2019s where Stork helps. Stork is going to select the most appropriate instance. It offers: Extensible service discovery mechanisms Built-in support for Consul and Kubernetes Customizable client load-balancing strategies A programmatic API and a managed approach A Quarkus integration, but Stork can be used in any environment","title":"Overview"},{"location":"#the-problem","text":"In distributed systems, applications typically need to call one another. In a monolithic application, components invoke one another through language-level method or procedure calls. In a traditional distributed system deployment, services run at fixed, well-known locations (schemes, hosts, and ports) and can call one another using HTTP/REST or some RPC mechanism. The service locations are often hardcoded in the application configuration. Nevertheless, a modern distributed system or microservice-based application typically runs in virtualized or containerized environments where the number of instances of a service and their locations change dynamically. IPs get randomly assigned, and instances can be created or destroyed at any time. With such dynamics, hard-coded locations are a dead-end.","title":"The problem"},{"location":"#the-solution","text":"Stork handles the service lookup and selection. It proposes an extensible set of service discovery mechanisms and load-balancing strategies.","title":"The solution"},{"location":"#what-if-the-infrastructure-provides-such-a-feature","text":"Some infrastructure, such as Kubernetes, provides service discoveries and load-balancing features. However, these mechanisms often lack flexibility. You cannot influence the service instance selection, and the load-balancing strategy is generally a simple round-robin . Stork provides more flexibility in the service instance selection. For example, it can select the fastest instance (based on the previous calls) to improve the response time. However, if you don\u2019t need that flexibility, just use the infrastructure layer.","title":"What if the infrastructure provides such a feature?"},{"location":"concepts/","text":"Concepts # This page presents the concepts used in Stork. When using Stork in a managed environment, such as Quarkus, all these concepts are hidden, as you only configure the lookup and selection. However, when using the programmatic API, you will use these concepts directly. Process overview # When using the programmatic API of Stork, you can: Retrieve the singleton Stork instance. This instance is configured with the set of Service it manages. Retrieve the Service you want to use. Each Service is associated with a name. Retrieve the ServiceInstance which will provide the metadata to access the actual service. Behind the scenes, Stork will handle the service lookup and selection. Note The service lookup and selection are asynchronous operations. Thus, the API returns instances of Uni . Stork # io.smallrye.stork.Stork is the entry-point of the API. The Stork instance is a singleton . It needs to be initialized once (when the application starts) and shutdown when the application stops: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package examples ; import io.smallrye.stork.Stork ; public class StorkEntryPointExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); // ... Stork . shutdown (); } } During the initialization, Stork looks for io.smallrye.stork.config.ConfigProvider SPI provider and retrieves the list of managed services: A service is identified by a name . A service has a service discovery configuration indicating how Stork will look for service instances A service can have a load-balancer configuration indicating how Stork can select the most appropriate instance. Service # A io.smallrye.stork.Service is the structure representing a service used by the application. Services are pre-configured with their name, service discovery, and optionally, their load-balancer. You retrieve a Service using the Stork#getService(String name) method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import io.smallrye.stork.api.Service ; import io.smallrye.stork.Stork ; public class StorkServiceExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); // ... Stork . shutdown (); } } The Service lets you retrieve the list of ServiceInstance , or select a single one, when a load-balancer is configured. Service Instance # The io.smallrye.stork.api.ServiceInstance represents an actual instance of the service. It provides the metadata to configure a client to interact with that specific instance of service. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package examples ; import java.time.Duration ; import java.util.List ; import io.smallrye.stork.Stork ; import io.smallrye.stork.api.Service ; import io.smallrye.stork.api.ServiceInstance ; public class StorkServiceLookupExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); List < ServiceInstance > instances = service . getInstances () . await (). atMost ( Duration . ofSeconds ( 5 )); // ... Stork . shutdown (); } } The service selection is a two-steps process: Service lookup - using the service discovery Service selection - using the load balancer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package examples ; import java.time.Duration ; import io.smallrye.stork.Stork ; import io.smallrye.stork.api.Service ; import io.smallrye.stork.api.ServiceInstance ; public class StorkServiceSelectionExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); ServiceInstance instance = service . selectInstance () . await (). atMost ( Duration . ofSeconds ( 5 )); System . out . println ( instance . getHost () + \":\" + instance . getPort ()); // ... Stork . shutdown (); } } Service Discovery # The io.smallrye.stork.api.ServiceDiscovery represents a service discovery mechanism, such as DNS, Consul, or Eureka. You can implement a custom service discovery for Stork by implementing the ServiceDiscoveryProvider interface. The corresponding ServiceRegistrarProviderLoader and RegistrarConfiguration classes will be automatically generated during compilation time. Please note that the ServiceDiscovery implementation must be non-blocking. Load Balancer # The io.smallrye.stork.api.LoadBalancer represents a load-balancer strategy, such as round-robin. To implement a custom load balancer for Stork, implement the LoadBalancerProvider interface. The corresponding LoadBalancerProviderLoader and Configuration classes will be automatically generated during compilation time. Please note that the LoadBalancer implementation, similarly to ServiceDiscovery must be non-blocking. Service registration # The io.smallrye.stork.api.ServiceRegistrar represents a service registration mechanism for Consul and Eureka. You can implement a custom service registrar for Stork by implementing the ServiceRegistrarProvider interface. The corresponding ServiceRegistrarProviderLoader and RegistrarConfiguration classes will be automatically generated during compilation time. Please note that the ServiceRegistrar implementation must be non-blocking.","title":"Concepts"},{"location":"concepts/#concepts","text":"This page presents the concepts used in Stork. When using Stork in a managed environment, such as Quarkus, all these concepts are hidden, as you only configure the lookup and selection. However, when using the programmatic API, you will use these concepts directly.","title":"Concepts"},{"location":"concepts/#process-overview","text":"When using the programmatic API of Stork, you can: Retrieve the singleton Stork instance. This instance is configured with the set of Service it manages. Retrieve the Service you want to use. Each Service is associated with a name. Retrieve the ServiceInstance which will provide the metadata to access the actual service. Behind the scenes, Stork will handle the service lookup and selection. Note The service lookup and selection are asynchronous operations. Thus, the API returns instances of Uni .","title":"Process overview"},{"location":"concepts/#stork","text":"io.smallrye.stork.Stork is the entry-point of the API. The Stork instance is a singleton . It needs to be initialized once (when the application starts) and shutdown when the application stops: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package examples ; import io.smallrye.stork.Stork ; public class StorkEntryPointExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); // ... Stork . shutdown (); } } During the initialization, Stork looks for io.smallrye.stork.config.ConfigProvider SPI provider and retrieves the list of managed services: A service is identified by a name . A service has a service discovery configuration indicating how Stork will look for service instances A service can have a load-balancer configuration indicating how Stork can select the most appropriate instance.","title":"Stork"},{"location":"concepts/#service","text":"A io.smallrye.stork.Service is the structure representing a service used by the application. Services are pre-configured with their name, service discovery, and optionally, their load-balancer. You retrieve a Service using the Stork#getService(String name) method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import io.smallrye.stork.api.Service ; import io.smallrye.stork.Stork ; public class StorkServiceExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); // ... Stork . shutdown (); } } The Service lets you retrieve the list of ServiceInstance , or select a single one, when a load-balancer is configured.","title":"Service"},{"location":"concepts/#service-instance","text":"The io.smallrye.stork.api.ServiceInstance represents an actual instance of the service. It provides the metadata to configure a client to interact with that specific instance of service. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package examples ; import java.time.Duration ; import java.util.List ; import io.smallrye.stork.Stork ; import io.smallrye.stork.api.Service ; import io.smallrye.stork.api.ServiceInstance ; public class StorkServiceLookupExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); List < ServiceInstance > instances = service . getInstances () . await (). atMost ( Duration . ofSeconds ( 5 )); // ... Stork . shutdown (); } } The service selection is a two-steps process: Service lookup - using the service discovery Service selection - using the load balancer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package examples ; import java.time.Duration ; import io.smallrye.stork.Stork ; import io.smallrye.stork.api.Service ; import io.smallrye.stork.api.ServiceInstance ; public class StorkServiceSelectionExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); ServiceInstance instance = service . selectInstance () . await (). atMost ( Duration . ofSeconds ( 5 )); System . out . println ( instance . getHost () + \":\" + instance . getPort ()); // ... Stork . shutdown (); } }","title":"Service Instance"},{"location":"concepts/#service-discovery","text":"The io.smallrye.stork.api.ServiceDiscovery represents a service discovery mechanism, such as DNS, Consul, or Eureka. You can implement a custom service discovery for Stork by implementing the ServiceDiscoveryProvider interface. The corresponding ServiceRegistrarProviderLoader and RegistrarConfiguration classes will be automatically generated during compilation time. Please note that the ServiceDiscovery implementation must be non-blocking.","title":"Service Discovery"},{"location":"concepts/#load-balancer","text":"The io.smallrye.stork.api.LoadBalancer represents a load-balancer strategy, such as round-robin. To implement a custom load balancer for Stork, implement the LoadBalancerProvider interface. The corresponding LoadBalancerProviderLoader and Configuration classes will be automatically generated during compilation time. Please note that the LoadBalancer implementation, similarly to ServiceDiscovery must be non-blocking.","title":"Load Balancer"},{"location":"concepts/#service-registration","text":"The io.smallrye.stork.api.ServiceRegistrar represents a service registration mechanism for Consul and Eureka. You can implement a custom service registrar for Stork by implementing the ServiceRegistrarProvider interface. The corresponding ServiceRegistrarProviderLoader and RegistrarConfiguration classes will be automatically generated during compilation time. Please note that the ServiceRegistrar implementation must be non-blocking.","title":"Service registration"},{"location":"programmatic-api/","text":"Stork Programmatic API # Stork proposes a programmatic API that lets you register new service Definitions and do manual lookup and selection. When using the programmatic API of Stork, you can: Retrieve the singleton Stork instance. This instance is configured with the set of Services it manages. Register new service definition. Retrieve the Service you want to use. Each Service is associated with a name. Retrieve the ServiceInstance, which will provide the metadata to access the actual instance. Initializing Stork # If your framework does not already provide a configured Stork instance, you need to do: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import io.smallrye.stork.Stork ; import io.smallrye.stork.api.ServiceDefinition ; import io.smallrye.stork.api.ServiceInstance ; import io.smallrye.stork.loadbalancer.random.RandomConfiguration ; import io.smallrye.stork.servicediscovery.staticlist.StaticConfiguration ; import java.time.Duration ; public class InitializationExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); // ... } } Adding service dynamically # To register a new ServiceDefinition , use the defineIfAbsent method: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package examples ; import io.smallrye.stork.Stork ; import io.smallrye.stork.api.ServiceDefinition ; import io.smallrye.stork.loadbalancer.random.RandomConfiguration ; import io.smallrye.stork.servicediscovery.staticlist.StaticConfiguration ; public class DefinitionExample { public static void example ( Stork stork ) { String example = \"localhost:8080, localhost:8081\" ; // A service using a static list of locations as discovery // As not set, it defaults to round-robin to select the instance. stork . defineIfAbsent ( \"my-service\" , ServiceDefinition . of ( new StaticConfiguration (). withAddressList ( example ))); // Another service using the random selection strategy, instead of round-robin stork . defineIfAbsent ( \"my-second-service\" , ServiceDefinition . of ( new StaticConfiguration (). withAddressList ( example ), new RandomConfiguration ())); } } The ServiceDefinition instances can be created from: A service discovery configuration - these classes are provided by the service discovery implementations, An optional load balancer configuration - these classes are provided by the load balancer implementations Attributes from the service discovery and load balancer can be configured from the Configuration classes. Looking for service instances # To list the service instances for a given service, or to select an instance according to the load balancer strategy, use the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package examples ; import io.smallrye.mutiny.Uni ; import io.smallrye.stork.Stork ; import io.smallrye.stork.api.Service ; import io.smallrye.stork.api.ServiceDefinition ; import io.smallrye.stork.api.ServiceInstance ; import io.smallrye.stork.loadbalancer.random.RandomConfiguration ; import io.smallrye.stork.servicediscovery.staticlist.StaticConfiguration ; import java.util.List ; import java.util.Map ; public class LookupExample { public static void example ( Stork stork ) { Service service = stork . getService ( \"my-service\" ); // Gets all the available instances: Uni < List < ServiceInstance >> instances = service . getInstances (); // Select one instance using the load balancing strategy Uni < ServiceInstance > instance = service . selectInstance (); // Gets all the managed services: Map < String , Service > services = stork . getServices (); } } The lookup and selection methods are returning Uni as these processes are asynchronous. All in one example # The following snippet provides an all in one example of the Stork programmatic API: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package examples ; import io.smallrye.stork.Stork ; import io.smallrye.stork.api.ServiceDefinition ; import io.smallrye.stork.api.ServiceInstance ; import io.smallrye.stork.loadbalancer.random.RandomConfiguration ; import io.smallrye.stork.servicediscovery.staticlist.StaticConfiguration ; import java.time.Duration ; public class StorkApiExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); String example = \"localhost:8080, localhost:8082\" ; // A service using a static list of locations as discovery // As not set, it defaults to round-robin to select the instance. stork . defineIfAbsent ( \"my-service\" , ServiceDefinition . of ( new StaticConfiguration (). withAddressList ( example ))); // Another service using the random selection strategy, instead of round-robin stork . defineIfAbsent ( \"my-second-service\" , ServiceDefinition . of ( new StaticConfiguration (). withAddressList ( example ), new RandomConfiguration ())); ServiceInstance instance = stork . getService ( \"my-second-service\" ). selectInstance () . await (). atMost ( Duration . ofSeconds ( 1 )); System . out . println ( instance . getHost () + \":\" + instance . getPort ()); } }","title":"Programmatic API"},{"location":"programmatic-api/#stork-programmatic-api","text":"Stork proposes a programmatic API that lets you register new service Definitions and do manual lookup and selection. When using the programmatic API of Stork, you can: Retrieve the singleton Stork instance. This instance is configured with the set of Services it manages. Register new service definition. Retrieve the Service you want to use. Each Service is associated with a name. Retrieve the ServiceInstance, which will provide the metadata to access the actual instance.","title":"Stork Programmatic API"},{"location":"programmatic-api/#initializing-stork","text":"If your framework does not already provide a configured Stork instance, you need to do: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import io.smallrye.stork.Stork ; import io.smallrye.stork.api.ServiceDefinition ; import io.smallrye.stork.api.ServiceInstance ; import io.smallrye.stork.loadbalancer.random.RandomConfiguration ; import io.smallrye.stork.servicediscovery.staticlist.StaticConfiguration ; import java.time.Duration ; public class InitializationExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); // ... } }","title":"Initializing Stork"},{"location":"programmatic-api/#adding-service-dynamically","text":"To register a new ServiceDefinition , use the defineIfAbsent method: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package examples ; import io.smallrye.stork.Stork ; import io.smallrye.stork.api.ServiceDefinition ; import io.smallrye.stork.loadbalancer.random.RandomConfiguration ; import io.smallrye.stork.servicediscovery.staticlist.StaticConfiguration ; public class DefinitionExample { public static void example ( Stork stork ) { String example = \"localhost:8080, localhost:8081\" ; // A service using a static list of locations as discovery // As not set, it defaults to round-robin to select the instance. stork . defineIfAbsent ( \"my-service\" , ServiceDefinition . of ( new StaticConfiguration (). withAddressList ( example ))); // Another service using the random selection strategy, instead of round-robin stork . defineIfAbsent ( \"my-second-service\" , ServiceDefinition . of ( new StaticConfiguration (). withAddressList ( example ), new RandomConfiguration ())); } } The ServiceDefinition instances can be created from: A service discovery configuration - these classes are provided by the service discovery implementations, An optional load balancer configuration - these classes are provided by the load balancer implementations Attributes from the service discovery and load balancer can be configured from the Configuration classes.","title":"Adding service dynamically"},{"location":"programmatic-api/#looking-for-service-instances","text":"To list the service instances for a given service, or to select an instance according to the load balancer strategy, use the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package examples ; import io.smallrye.mutiny.Uni ; import io.smallrye.stork.Stork ; import io.smallrye.stork.api.Service ; import io.smallrye.stork.api.ServiceDefinition ; import io.smallrye.stork.api.ServiceInstance ; import io.smallrye.stork.loadbalancer.random.RandomConfiguration ; import io.smallrye.stork.servicediscovery.staticlist.StaticConfiguration ; import java.util.List ; import java.util.Map ; public class LookupExample { public static void example ( Stork stork ) { Service service = stork . getService ( \"my-service\" ); // Gets all the available instances: Uni < List < ServiceInstance >> instances = service . getInstances (); // Select one instance using the load balancing strategy Uni < ServiceInstance > instance = service . selectInstance (); // Gets all the managed services: Map < String , Service > services = stork . getServices (); } } The lookup and selection methods are returning Uni as these processes are asynchronous.","title":"Looking for service instances"},{"location":"programmatic-api/#all-in-one-example","text":"The following snippet provides an all in one example of the Stork programmatic API: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package examples ; import io.smallrye.stork.Stork ; import io.smallrye.stork.api.ServiceDefinition ; import io.smallrye.stork.api.ServiceInstance ; import io.smallrye.stork.loadbalancer.random.RandomConfiguration ; import io.smallrye.stork.servicediscovery.staticlist.StaticConfiguration ; import java.time.Duration ; public class StorkApiExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); String example = \"localhost:8080, localhost:8082\" ; // A service using a static list of locations as discovery // As not set, it defaults to round-robin to select the instance. stork . defineIfAbsent ( \"my-service\" , ServiceDefinition . of ( new StaticConfiguration (). withAddressList ( example ))); // Another service using the random selection strategy, instead of round-robin stork . defineIfAbsent ( \"my-second-service\" , ServiceDefinition . of ( new StaticConfiguration (). withAddressList ( example ), new RandomConfiguration ())); ServiceInstance instance = stork . getService ( \"my-second-service\" ). selectInstance () . await (). atMost ( Duration . ofSeconds ( 1 )); System . out . println ( instance . getHost () + \":\" + instance . getPort ()); } }","title":"All in one example"},{"location":"quarkus/","text":"Using Stork with Quarkus # Quarkus is a Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM. Quarkus REST Client Reactive and gRPC extensions come with built-in integration with SmallRye Stork. This page describes how to use REST Client Reactive with Stork. Using gRPC with Stork is similar. We will use the Consul service discovery and the round-robin load balancer as examples. The project # You can create a Quarkus project with the REST Client Reactive extension using code.quarkus.io . The corresponding Quarkus guide describes the extension in more detail. The client # To use the REST client to communicate with a remote endpoint, you need to create an interface that describes how the communication should work. The client requires baseUri (or baseUrl ) pointing to the address of the remote endpoint. To use Stork to determine the actual address, set the scheme of the URI to stork and the hostname of the URI to the name of the Stork service. For example, the HelloClient below will use the Stork service called hello-service to determine the address of the destination, and /hello as the base path for queries: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import org.eclipse.microprofile.rest.client.inject.RegisterRestClient ; import javax.ws.rs.Consumes ; import javax.ws.rs.POST ; import javax.ws.rs.Path ; import javax.ws.rs.Produces ; import javax.ws.rs.core.MediaType ; @Path ( \"/\" ) @RegisterRestClient ( baseUri = \"stork://hello-service/hello\" ) public interface HelloClient { @POST @Produces ( MediaType . TEXT_PLAIN ) @Consumes ( MediaType . TEXT_PLAIN ) String echo ( String name ); } The service # In Stork, a Service consists of service discovery and a load balancer. The Service discovery is responsible for determining the ServiceInstance s, that is, available addresses for a service. The load balancer picks a single ServiceInstance for a call. Dependencies # To use the service discovery and the load balancer of your choosing, you need to add the appropriate dependencies to your application. For example, if you wish to use Consul and load-balance the calls with round-robin, add the following to your pom.xml : <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-consul </artifactId> </dependency> Note No need to add a dependency for the round-robin load-balancer. This strategy is built-in. Also, no need to specify the stork version, Quarkus imports the Stork BOM . When using Eureka, Kubernetes, or any other service discovery mechanism, or a different load balancer, replace the dependencies above with the ones you need. Based on the defined dependencies, Stork automatically registers providers for service discovery mechanisms and load balancers. The config # The last piece of the puzzle is the actual service configuration. If your Consul instance is running on localhost on port 8500 , service discovery configuration should look as follows: quarkus.stork.hello-service.service-discovery.type = consul quarkus.stork.hello-service.service-discovery.consul-host = localhost quarkus.stork.hello-service.service-discovery.consul-port = 8500 Note When no load-balancing is configured, Stork uses a round-robin.","title":"Using Stork with Quarkus"},{"location":"quarkus/#using-stork-with-quarkus","text":"Quarkus is a Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM. Quarkus REST Client Reactive and gRPC extensions come with built-in integration with SmallRye Stork. This page describes how to use REST Client Reactive with Stork. Using gRPC with Stork is similar. We will use the Consul service discovery and the round-robin load balancer as examples.","title":"Using Stork with Quarkus"},{"location":"quarkus/#the-project","text":"You can create a Quarkus project with the REST Client Reactive extension using code.quarkus.io . The corresponding Quarkus guide describes the extension in more detail.","title":"The project"},{"location":"quarkus/#the-client","text":"To use the REST client to communicate with a remote endpoint, you need to create an interface that describes how the communication should work. The client requires baseUri (or baseUrl ) pointing to the address of the remote endpoint. To use Stork to determine the actual address, set the scheme of the URI to stork and the hostname of the URI to the name of the Stork service. For example, the HelloClient below will use the Stork service called hello-service to determine the address of the destination, and /hello as the base path for queries: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import org.eclipse.microprofile.rest.client.inject.RegisterRestClient ; import javax.ws.rs.Consumes ; import javax.ws.rs.POST ; import javax.ws.rs.Path ; import javax.ws.rs.Produces ; import javax.ws.rs.core.MediaType ; @Path ( \"/\" ) @RegisterRestClient ( baseUri = \"stork://hello-service/hello\" ) public interface HelloClient { @POST @Produces ( MediaType . TEXT_PLAIN ) @Consumes ( MediaType . TEXT_PLAIN ) String echo ( String name ); }","title":"The client"},{"location":"quarkus/#the-service","text":"In Stork, a Service consists of service discovery and a load balancer. The Service discovery is responsible for determining the ServiceInstance s, that is, available addresses for a service. The load balancer picks a single ServiceInstance for a call.","title":"The service"},{"location":"quarkus/#dependencies","text":"To use the service discovery and the load balancer of your choosing, you need to add the appropriate dependencies to your application. For example, if you wish to use Consul and load-balance the calls with round-robin, add the following to your pom.xml : <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-consul </artifactId> </dependency> Note No need to add a dependency for the round-robin load-balancer. This strategy is built-in. Also, no need to specify the stork version, Quarkus imports the Stork BOM . When using Eureka, Kubernetes, or any other service discovery mechanism, or a different load balancer, replace the dependencies above with the ones you need. Based on the defined dependencies, Stork automatically registers providers for service discovery mechanisms and load balancers.","title":"Dependencies"},{"location":"quarkus/#the-config","text":"The last piece of the puzzle is the actual service configuration. If your Consul instance is running on localhost on port 8500 , service discovery configuration should look as follows: quarkus.stork.hello-service.service-discovery.type = consul quarkus.stork.hello-service.service-discovery.consul-host = localhost quarkus.stork.hello-service.service-discovery.consul-port = 8500 Note When no load-balancing is configured, Stork uses a round-robin.","title":"The config"},{"location":"load-balancer/custom-load-balancer/","text":"Implement your own load balancer mechanism # Stork is extensible, and you can implement your service selection (load-balancer) mechanism. Dependencies # To implement your Load Balancer Provider , make sure your project depends on Core and Configuration Generator. The former brings classes necessary to implement custom load balancer, the latter contains an annotation processor that generates classes needed by Stork. <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-core </artifactId> <version> 1.4.1 </version> </dependency> <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-configuration-generator </artifactId> <scope> provided </scope> <!-- provided scope is sufficient for the annotation processor --> <version> 1.4.1 </version> </dependency> Implementing a load balancer provider # Load balancer implementation consists of three elements: LoadBalancer which is responsible for selecting service instances for a single Stork service, LoadBalancerProvider which creates instances of LoadBalancer for a given load balancer type , $typeConfiguration which is a configuration for the load balancer. This class is automatically generated. A type , for example acme-load-balancer , identifies each provider. This type is used in the configuration to reference the provider: stork standalone stork in quarkus stork.my-service.load-balancer.type = acme-load-balancer quarkus.stork.my-service.load-balancer.type = acme-load-balancer A LoadBalancerProvider implementation needs to be annotated with @LoadBalancerType that defines the type . Any configuration properties that the provider expects should be defined with @LoadBalancerAttribute annotations placed on the provider. A load balancer provider class should look as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package examples ; import io.smallrye.stork.api.LoadBalancer ; import io.smallrye.stork.api.ServiceDiscovery ; import io.smallrye.stork.api.config.LoadBalancerAttribute ; import io.smallrye.stork.api.config.LoadBalancerType ; import io.smallrye.stork.spi.LoadBalancerProvider ; @LoadBalancerType ( \"acme-load-balancer\" ) @LoadBalancerAttribute ( name = \"my-attribute\" , description = \"Attribute that alters the behavior of the LoadBalancer\" ) public class AcmeLoadBalancerProvider implements LoadBalancerProvider < AcmeLoadBalancerConfiguration > { @Override public LoadBalancer createLoadBalancer ( AcmeLoadBalancerConfiguration config , ServiceDiscovery serviceDiscovery ) { return new AcmeLoadBalancer ( config ); } } Note, that the LoadBalancerProvider interface takes a configuration class as a parameter. This configuration class is generated automatically by the Configuration Generator . Its name is created by appending Configuration to the load balancer type, like AcmeLoadBalancerConfiguration . The next step is to implement the LoadBalancer interface. The essence of load balancers\u2019 work happens in the selectServiceInstance method. The method returns a single ServiceInstance from a collection. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package examples ; import java.util.ArrayList ; import java.util.Collection ; import java.util.Random ; import io.smallrye.stork.api.LoadBalancer ; import io.smallrye.stork.api.NoServiceInstanceFoundException ; import io.smallrye.stork.api.ServiceInstance ; public class AcmeLoadBalancer implements LoadBalancer { private final Random random ; public AcmeLoadBalancer ( AcmeLoadBalancerConfiguration config ) { random = new Random (); } @Override public ServiceInstance selectServiceInstance ( Collection < ServiceInstance > serviceInstances ) { if ( serviceInstances . isEmpty ()) { throw new NoServiceInstanceFoundException ( \"No services found.\" ); } int index = random . nextInt ( serviceInstances . size ()); return new ArrayList <> ( serviceInstances ). get ( index ); } @Override public boolean requiresStrictRecording () { return false ; } } This implementation is simplistic and just picks a random instance from the received list. Some load balancers make the pick based on statistics such as calls in progress or response times, or amount of errors of a service instance. To collect this information in your load balancer, you can wrap the selected service instance into ServiceInstanceWithStatGathering . Load balancers based on statistics often expect that an operation using a selected service instance is marked as started before the next selection. By default, Stork assumes that a LoadBalancer requires this and guards the calls accordingly. If this is not the case for your implementation, override the requiresStrictRecording() method to return false . Using your load balancer # In the project using it, don\u2019t forget to add the dependency on the module providing your implementation. Then, in the configuration, just add: stork standalone stork in quarkus stork.my-service.service-discovery.type = ... stork.my-service.load-balancer.type = acme-load-balancer\\ quarkus.stork.my-service.service-discovery.type = ... quarkus.stork.my-service.load-balancer.type = acme-load-balancer Then, Stork will use your implementation to select the my-service service instance. Using your load balancer using the programmatic API # When building your load balancer project, the configuration generator creates a configuration class. This class can be used to configure your load balancer using the Stork programmatic API. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package examples ; import io.smallrye.mutiny.Uni ; import io.smallrye.stork.api.ServiceDefinition ; import io.smallrye.stork.api.ServiceInstance ; import io.smallrye.stork.api.StorkServiceRegistry ; import io.smallrye.stork.servicediscovery.staticlist.StaticConfiguration ; public class AcmeSelectorApiUsage { public void example ( StorkServiceRegistry stork ) { String list = \"localhost:8080, localhost:8081\" ; stork . defineIfAbsent ( \"my-service\" , ServiceDefinition . of ( new StaticConfiguration (). withAddressList ( list ), new AcmeLoadBalancerConfiguration (). withMyAttribute ( \"my-value\" )) ); Uni < ServiceInstance > uni = stork . getService ( \"my-service\" ). selectInstance (); } } Remember that attributes, like my-attribute , are declared using the @LoadBalancerAttribute annotation on the LoadBalancerProvider implementation.","title":"Custom Load Balancer"},{"location":"load-balancer/custom-load-balancer/#implement-your-own-load-balancer-mechanism","text":"Stork is extensible, and you can implement your service selection (load-balancer) mechanism.","title":"Implement your own load balancer mechanism"},{"location":"load-balancer/custom-load-balancer/#dependencies","text":"To implement your Load Balancer Provider , make sure your project depends on Core and Configuration Generator. The former brings classes necessary to implement custom load balancer, the latter contains an annotation processor that generates classes needed by Stork. <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-core </artifactId> <version> 1.4.1 </version> </dependency> <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-configuration-generator </artifactId> <scope> provided </scope> <!-- provided scope is sufficient for the annotation processor --> <version> 1.4.1 </version> </dependency>","title":"Dependencies"},{"location":"load-balancer/custom-load-balancer/#implementing-a-load-balancer-provider","text":"Load balancer implementation consists of three elements: LoadBalancer which is responsible for selecting service instances for a single Stork service, LoadBalancerProvider which creates instances of LoadBalancer for a given load balancer type , $typeConfiguration which is a configuration for the load balancer. This class is automatically generated. A type , for example acme-load-balancer , identifies each provider. This type is used in the configuration to reference the provider: stork standalone stork in quarkus stork.my-service.load-balancer.type = acme-load-balancer quarkus.stork.my-service.load-balancer.type = acme-load-balancer A LoadBalancerProvider implementation needs to be annotated with @LoadBalancerType that defines the type . Any configuration properties that the provider expects should be defined with @LoadBalancerAttribute annotations placed on the provider. A load balancer provider class should look as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package examples ; import io.smallrye.stork.api.LoadBalancer ; import io.smallrye.stork.api.ServiceDiscovery ; import io.smallrye.stork.api.config.LoadBalancerAttribute ; import io.smallrye.stork.api.config.LoadBalancerType ; import io.smallrye.stork.spi.LoadBalancerProvider ; @LoadBalancerType ( \"acme-load-balancer\" ) @LoadBalancerAttribute ( name = \"my-attribute\" , description = \"Attribute that alters the behavior of the LoadBalancer\" ) public class AcmeLoadBalancerProvider implements LoadBalancerProvider < AcmeLoadBalancerConfiguration > { @Override public LoadBalancer createLoadBalancer ( AcmeLoadBalancerConfiguration config , ServiceDiscovery serviceDiscovery ) { return new AcmeLoadBalancer ( config ); } } Note, that the LoadBalancerProvider interface takes a configuration class as a parameter. This configuration class is generated automatically by the Configuration Generator . Its name is created by appending Configuration to the load balancer type, like AcmeLoadBalancerConfiguration . The next step is to implement the LoadBalancer interface. The essence of load balancers\u2019 work happens in the selectServiceInstance method. The method returns a single ServiceInstance from a collection. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package examples ; import java.util.ArrayList ; import java.util.Collection ; import java.util.Random ; import io.smallrye.stork.api.LoadBalancer ; import io.smallrye.stork.api.NoServiceInstanceFoundException ; import io.smallrye.stork.api.ServiceInstance ; public class AcmeLoadBalancer implements LoadBalancer { private final Random random ; public AcmeLoadBalancer ( AcmeLoadBalancerConfiguration config ) { random = new Random (); } @Override public ServiceInstance selectServiceInstance ( Collection < ServiceInstance > serviceInstances ) { if ( serviceInstances . isEmpty ()) { throw new NoServiceInstanceFoundException ( \"No services found.\" ); } int index = random . nextInt ( serviceInstances . size ()); return new ArrayList <> ( serviceInstances ). get ( index ); } @Override public boolean requiresStrictRecording () { return false ; } } This implementation is simplistic and just picks a random instance from the received list. Some load balancers make the pick based on statistics such as calls in progress or response times, or amount of errors of a service instance. To collect this information in your load balancer, you can wrap the selected service instance into ServiceInstanceWithStatGathering . Load balancers based on statistics often expect that an operation using a selected service instance is marked as started before the next selection. By default, Stork assumes that a LoadBalancer requires this and guards the calls accordingly. If this is not the case for your implementation, override the requiresStrictRecording() method to return false .","title":"Implementing a load balancer provider"},{"location":"load-balancer/custom-load-balancer/#using-your-load-balancer","text":"In the project using it, don\u2019t forget to add the dependency on the module providing your implementation. Then, in the configuration, just add: stork standalone stork in quarkus stork.my-service.service-discovery.type = ... stork.my-service.load-balancer.type = acme-load-balancer\\ quarkus.stork.my-service.service-discovery.type = ... quarkus.stork.my-service.load-balancer.type = acme-load-balancer Then, Stork will use your implementation to select the my-service service instance.","title":"Using your load balancer"},{"location":"load-balancer/custom-load-balancer/#using-your-load-balancer-using-the-programmatic-api","text":"When building your load balancer project, the configuration generator creates a configuration class. This class can be used to configure your load balancer using the Stork programmatic API. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package examples ; import io.smallrye.mutiny.Uni ; import io.smallrye.stork.api.ServiceDefinition ; import io.smallrye.stork.api.ServiceInstance ; import io.smallrye.stork.api.StorkServiceRegistry ; import io.smallrye.stork.servicediscovery.staticlist.StaticConfiguration ; public class AcmeSelectorApiUsage { public void example ( StorkServiceRegistry stork ) { String list = \"localhost:8080, localhost:8081\" ; stork . defineIfAbsent ( \"my-service\" , ServiceDefinition . of ( new StaticConfiguration (). withAddressList ( list ), new AcmeLoadBalancerConfiguration (). withMyAttribute ( \"my-value\" )) ); Uni < ServiceInstance > uni = stork . getService ( \"my-service\" ). selectInstance (); } } Remember that attributes, like my-attribute , are declared using the @LoadBalancerAttribute annotation on the LoadBalancerProvider implementation.","title":"Using your load balancer using the programmatic API"},{"location":"load-balancer/least-requests/","text":"Least Requests Load Balancing # The least-requests load balancing strategy monitors the number of inflight calls and selects the less-used instance. This strategy keeps track of the inflight calls made by the application and picks the service instance with the smallest number of inflight requests: when the selection happens, the service instance with the smallest number of inflight requests is selected, and this number is incremented when the operation completes, successfully or not, the number of inflight requests is decremented Dependency # First, you need to add the least-requests load-balancer to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-load-balancer-least-requests </artifactId> <version> 1.4.1 </version> </dependency> Configuration # For each service expected to use a least-response-time selection, configure the load-balancer to be least-requests : stork standalone stork in quarkus stork.my-service.service-discovery.type = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer.type = least-requests quarkus.stork.my-service.service-discovery.type = ... quarkus.stork.my-service.service-discovery... = ... quarkus.stork.my-service.load-balancer.type = least-requests","title":"Least Requests"},{"location":"load-balancer/least-requests/#least-requests-load-balancing","text":"The least-requests load balancing strategy monitors the number of inflight calls and selects the less-used instance. This strategy keeps track of the inflight calls made by the application and picks the service instance with the smallest number of inflight requests: when the selection happens, the service instance with the smallest number of inflight requests is selected, and this number is incremented when the operation completes, successfully or not, the number of inflight requests is decremented","title":"Least Requests Load Balancing"},{"location":"load-balancer/least-requests/#dependency","text":"First, you need to add the least-requests load-balancer to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-load-balancer-least-requests </artifactId> <version> 1.4.1 </version> </dependency>","title":"Dependency"},{"location":"load-balancer/least-requests/#configuration","text":"For each service expected to use a least-response-time selection, configure the load-balancer to be least-requests : stork standalone stork in quarkus stork.my-service.service-discovery.type = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer.type = least-requests quarkus.stork.my-service.service-discovery.type = ... quarkus.stork.my-service.service-discovery... = ... quarkus.stork.my-service.load-balancer.type = least-requests","title":"Configuration"},{"location":"load-balancer/power-of-two-choices/","text":"Power Of Two Choices Load Balancing # The power-of-two-choices load balancing selects two random service instances and then chooses the one with the least inflight requests. It avoids the overhead of least-requests and the worst case for random where it selects a busy destination. This strategy acts as follows: when the selection happens, it picks two random instances from the list, it returns the least loaded instance (based on the number of inflight requests), when the operation completes, successfully or not, the number of inflight requests for the instance is decremented. Check The Power of Two Random Choices paper to learn more about this pattern and the benefits. Dependency # First, you need to add the random load-balancer to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-load-balancer-power-of-two-choices </artifactId> <version> 1.4.1 </version> </dependency> Configuration # For each service expected to use a random service selection, configure the load-balancer to be power-of-two-choices : stork standalone stork in quarkus stork.my-service.service-discovery.type = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer.type = power-of-two-choices quarkus.stork.my-service.service-discovery.type = ... quarkus.stork.my-service.service-discovery... = ... quarkus.stork.my-service.load-balancer.type = power-of-two-choices Supported attributes are the following:","title":"Power Of Two Choices"},{"location":"load-balancer/power-of-two-choices/#power-of-two-choices-load-balancing","text":"The power-of-two-choices load balancing selects two random service instances and then chooses the one with the least inflight requests. It avoids the overhead of least-requests and the worst case for random where it selects a busy destination. This strategy acts as follows: when the selection happens, it picks two random instances from the list, it returns the least loaded instance (based on the number of inflight requests), when the operation completes, successfully or not, the number of inflight requests for the instance is decremented. Check The Power of Two Random Choices paper to learn more about this pattern and the benefits.","title":"Power Of Two Choices Load Balancing"},{"location":"load-balancer/power-of-two-choices/#dependency","text":"First, you need to add the random load-balancer to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-load-balancer-power-of-two-choices </artifactId> <version> 1.4.1 </version> </dependency>","title":"Dependency"},{"location":"load-balancer/power-of-two-choices/#configuration","text":"For each service expected to use a random service selection, configure the load-balancer to be power-of-two-choices : stork standalone stork in quarkus stork.my-service.service-discovery.type = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer.type = power-of-two-choices quarkus.stork.my-service.service-discovery.type = ... quarkus.stork.my-service.service-discovery... = ... quarkus.stork.my-service.load-balancer.type = power-of-two-choices Supported attributes are the following:","title":"Configuration"},{"location":"load-balancer/random/","text":"Random Load Balancing # The random load balancing is a straightforward service instance selection solution that picks a random instance every time. Dependency # First, you need to add the random load-balancer to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-load-balancer-random </artifactId> <version> 1.4.1 </version> </dependency> Configuration # For each service expected to use a random service selection, configure the load-balancer to be random : stork standalone stork in quarkus stork.my-service.service-discovery.type = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer.type = random quarkus.stork.my-service.service-discovery.type = ... quarkus.stork.my-service.service-discovery... = ... quarkus.stork.my-service.load-balancer.type = random Supported attributes are the following:","title":"Random"},{"location":"load-balancer/random/#random-load-balancing","text":"The random load balancing is a straightforward service instance selection solution that picks a random instance every time.","title":"Random Load Balancing"},{"location":"load-balancer/random/#dependency","text":"First, you need to add the random load-balancer to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-load-balancer-random </artifactId> <version> 1.4.1 </version> </dependency>","title":"Dependency"},{"location":"load-balancer/random/#configuration","text":"For each service expected to use a random service selection, configure the load-balancer to be random : stork standalone stork in quarkus stork.my-service.service-discovery.type = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer.type = random quarkus.stork.my-service.service-discovery.type = ... quarkus.stork.my-service.service-discovery... = ... quarkus.stork.my-service.load-balancer.type = random Supported attributes are the following:","title":"Configuration"},{"location":"load-balancer/response-time/","text":"Least Response Time Load Balancing # The least-response-time load balancing strategy collects response times of the calls made with service instances and picks an instance based on this information. Erroneous responses are treated as responses with a long response time, by default 60 seconds. This can be controlled with the error-penalty attribute. The algorithm for service instance selection is as follows: if there is a service instance that wasn\u2019t used before - use it, otherwise: if there are any service instances with collected response times - select the one for which score is the lowest, otherwise: select a random instance The score for an instance decreases in time if an instance is not used. This way we ensure that instances that haven\u2019t been used in a long time, are retried. For the details on the score calculation, see Score calculation Dependency # To use this load balancer, start with adding the least-response-time load-balancer dependency to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-load-balancer-least-response-time </artifactId> <version> 1.4.1 </version> </dependency> Configuration # For each service expected to use a least-response-time selection, configure the load-balancer to be least-response-time : stork standalone stork in quarkus stork.my-service.service-discovery.type = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer.type = least-response-time quarkus.stork.my-service.service-discovery.type = ... quarkus.stork.my-service.service-discovery... = ... quarkus.stork.my-service.load-balancer.type = least-response-time The following attributes are supported: Score calculation # The score of a service instance is calculated by dividing a weighted sum of response times by sum of the weighs. The result is additionally adjusted to account for instances that haven\u2019t been used for a long time. Let: \\(n\\) denote how many instance selections were made so far \\(t_i\\) denote the response time for call \\(i\\) \\(n_i\\) denote the number of instance selections done until the moment of recording the response time for call \\(i\\) \\(n_{max}\\) denote the number of instance selections at the moment of last call recorded with this instance \\(\\delta\\) denote a configurable declining-factor The idea for the weight is to decrease the importance of the data collected long time (many calls) ago. For call \\(i\\) , the weight is calculated as follows: $$ w_i = \\delta ^ {(n - n_i)} $$ The score of a service instance is calculated as: $$ score(n) = \\delta^{n - n_{max}} * \\frac{\\sum_i t_i * w_i}{\\sum_i w_i} = \\delta^{n - n_{max}} * \\frac{\\sum_i t_i * \\delta^{n - n_i}}{\\sum_i \\delta^{n - n_i}} $$ The declining-factor should be in \\((0, 1]\\) , the default is \\(0.9\\) . Using a lower value makes the older response times less important.","title":"Response Time"},{"location":"load-balancer/response-time/#least-response-time-load-balancing","text":"The least-response-time load balancing strategy collects response times of the calls made with service instances and picks an instance based on this information. Erroneous responses are treated as responses with a long response time, by default 60 seconds. This can be controlled with the error-penalty attribute. The algorithm for service instance selection is as follows: if there is a service instance that wasn\u2019t used before - use it, otherwise: if there are any service instances with collected response times - select the one for which score is the lowest, otherwise: select a random instance The score for an instance decreases in time if an instance is not used. This way we ensure that instances that haven\u2019t been used in a long time, are retried. For the details on the score calculation, see Score calculation","title":"Least Response Time Load Balancing"},{"location":"load-balancer/response-time/#dependency","text":"To use this load balancer, start with adding the least-response-time load-balancer dependency to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-load-balancer-least-response-time </artifactId> <version> 1.4.1 </version> </dependency>","title":"Dependency"},{"location":"load-balancer/response-time/#configuration","text":"For each service expected to use a least-response-time selection, configure the load-balancer to be least-response-time : stork standalone stork in quarkus stork.my-service.service-discovery.type = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer.type = least-response-time quarkus.stork.my-service.service-discovery.type = ... quarkus.stork.my-service.service-discovery... = ... quarkus.stork.my-service.load-balancer.type = least-response-time The following attributes are supported:","title":"Configuration"},{"location":"load-balancer/response-time/#score-calculation","text":"The score of a service instance is calculated by dividing a weighted sum of response times by sum of the weighs. The result is additionally adjusted to account for instances that haven\u2019t been used for a long time. Let: \\(n\\) denote how many instance selections were made so far \\(t_i\\) denote the response time for call \\(i\\) \\(n_i\\) denote the number of instance selections done until the moment of recording the response time for call \\(i\\) \\(n_{max}\\) denote the number of instance selections at the moment of last call recorded with this instance \\(\\delta\\) denote a configurable declining-factor The idea for the weight is to decrease the importance of the data collected long time (many calls) ago. For call \\(i\\) , the weight is calculated as follows: $$ w_i = \\delta ^ {(n - n_i)} $$ The score of a service instance is calculated as: $$ score(n) = \\delta^{n - n_{max}} * \\frac{\\sum_i t_i * w_i}{\\sum_i w_i} = \\delta^{n - n_{max}} * \\frac{\\sum_i t_i * \\delta^{n - n_i}}{\\sum_i \\delta^{n - n_i}} $$ The declining-factor should be in \\((0, 1]\\) , the default is \\(0.9\\) . Using a lower value makes the older response times less important.","title":"Score calculation"},{"location":"load-balancer/round-robin/","text":"Round-Robin Load Balancing # The round-robin is a straightforward load-balancing solution that just iterates over the set of service instances. While being simple, this solution shares the load among the instances and may be sufficient in many cases. The round-robin strategy is the default load-balancing strategy. It is provided by Stork itself, and so does not require an additional dependency. Configuration # There is no need to configure the load-balancing strategy to be round-robin . Stork automatically uses this strategy when none are configured. However, you can also configure it explicitly as follows: stork standalone stork in quarkus stork.my-service.service-discovery.type = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer.type = round-robin quarkus.stork.my-service.service-discovery.type = ... quarkus.stork.my-service.service-discovery... = ... quarkus.stork.my-service.load-balancer.type = round-robin","title":"Round Robin"},{"location":"load-balancer/round-robin/#round-robin-load-balancing","text":"The round-robin is a straightforward load-balancing solution that just iterates over the set of service instances. While being simple, this solution shares the load among the instances and may be sufficient in many cases. The round-robin strategy is the default load-balancing strategy. It is provided by Stork itself, and so does not require an additional dependency.","title":"Round-Robin Load Balancing"},{"location":"load-balancer/round-robin/#configuration","text":"There is no need to configure the load-balancing strategy to be round-robin . Stork automatically uses this strategy when none are configured. However, you can also configure it explicitly as follows: stork standalone stork in quarkus stork.my-service.service-discovery.type = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer.type = round-robin quarkus.stork.my-service.service-discovery.type = ... quarkus.stork.my-service.service-discovery... = ... quarkus.stork.my-service.load-balancer.type = round-robin","title":"Configuration"},{"location":"load-balancer/sticky/","text":"Sticky Load Balancing # The sticky load balancer selects a single service instance and keeps using it until it fails. Then, it selects another one. It is possible to configure a backoff time to specify for how long a failing service instance should not be retried. Precisely, the load balancer works as follows: if no service instance has been selected so far, select the first instance from the collection; else if the previously selected service instance has not failed, and is still available, return it; else return the first available service instance that has no recorded failure, if one exists; else, find the available instance for which the time since the last failure is the longest, and if the backoff time since the failure passed, return it; or, throw an NoAcceptableServiceInstanceFoundException as no acceptable instances are available. Configuration # To use the sticky load service selection strategy, set the load balancer type to sticky : stork standalone stork in quarkus stork.my-service.service-discovery.type = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer.type = sticky quarkus.stork.my-service.service-discovery.type = ... quarkus.stork.my-service.service-discovery... = ... quarkus.stork.my-service.load-balancer.type = sticky The following attributes are supported:","title":"Sticky"},{"location":"load-balancer/sticky/#sticky-load-balancing","text":"The sticky load balancer selects a single service instance and keeps using it until it fails. Then, it selects another one. It is possible to configure a backoff time to specify for how long a failing service instance should not be retried. Precisely, the load balancer works as follows: if no service instance has been selected so far, select the first instance from the collection; else if the previously selected service instance has not failed, and is still available, return it; else return the first available service instance that has no recorded failure, if one exists; else, find the available instance for which the time since the last failure is the longest, and if the backoff time since the failure passed, return it; or, throw an NoAcceptableServiceInstanceFoundException as no acceptable instances are available.","title":"Sticky Load Balancing"},{"location":"load-balancer/sticky/#configuration","text":"To use the sticky load service selection strategy, set the load balancer type to sticky : stork standalone stork in quarkus stork.my-service.service-discovery.type = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer.type = sticky quarkus.stork.my-service.service-discovery.type = ... quarkus.stork.my-service.service-discovery... = ... quarkus.stork.my-service.load-balancer.type = sticky The following attributes are supported:","title":"Configuration"},{"location":"service-discovery/composite/","text":"Composite Service Discovery # Some organizations use hybrid infrastructure. In such an infrastructure, different service instances may be discoverable via different service discovery providers. E.g. when serviceA is being migrated from a VM to Kubernetes, its older versions can be discovered via Consul and newer via Kubernetes. composite service discovery addresses this problem by letting you define a service that consists of multiple services. Dependency # To use the composite service discovery, first add the appropriate Service Discovery provider dependency to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-composite </artifactId> <version> 1.4.1 </version> </dependency> Configuration # For each service that should consist of multiple services, configure the service discovery type , and set the services property to a comma separated list of services: stork standalone stork in quarkus stork.my-service.service-discovery.type = composite stork.my-service.service-discovery.services = serviceA,serviceB stork.serviceA.service-discovery.type = ... stork.serviceB.service-discovery.type = ... quarkus.stork.my-service.service-discovery.type = composite quarkus.stork.my-service.service-discovery.services = serviceA,serviceB quarkus.stork.serviceA.service-discovery.type = ... quarkus.stork.serviceB.service-discovery.type = ... Remember to define the services that make up your composite service. These are all the parameters of the composite service discovery:","title":"Composite"},{"location":"service-discovery/composite/#composite-service-discovery","text":"Some organizations use hybrid infrastructure. In such an infrastructure, different service instances may be discoverable via different service discovery providers. E.g. when serviceA is being migrated from a VM to Kubernetes, its older versions can be discovered via Consul and newer via Kubernetes. composite service discovery addresses this problem by letting you define a service that consists of multiple services.","title":"Composite Service Discovery"},{"location":"service-discovery/composite/#dependency","text":"To use the composite service discovery, first add the appropriate Service Discovery provider dependency to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-composite </artifactId> <version> 1.4.1 </version> </dependency>","title":"Dependency"},{"location":"service-discovery/composite/#configuration","text":"For each service that should consist of multiple services, configure the service discovery type , and set the services property to a comma separated list of services: stork standalone stork in quarkus stork.my-service.service-discovery.type = composite stork.my-service.service-discovery.services = serviceA,serviceB stork.serviceA.service-discovery.type = ... stork.serviceB.service-discovery.type = ... quarkus.stork.my-service.service-discovery.type = composite quarkus.stork.my-service.service-discovery.services = serviceA,serviceB quarkus.stork.serviceA.service-discovery.type = ... quarkus.stork.serviceB.service-discovery.type = ... Remember to define the services that make up your composite service. These are all the parameters of the composite service discovery:","title":"Configuration"},{"location":"service-discovery/consul/","text":"Consul Service Discovery # Consul is a distributed, highly available, and data center aware solution to connect and configure applications across dynamic, distributed infrastructure. It\u2019s often used as service discovery backend to register and locate the services composing your system. Consul makes it simple for services to register themselves and to discover other services via a DNS or HTTP interface. External services can be registered as well. This page explains how Stork can use Consul to handle the service discovery and service registration. Dependency # First, you need to add the Stork Consul Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-consul </artifactId> <version> 1.4.1 </version> </dependency> Service discovery configuration # For each service that should get the service instances from Consul, configure the service discovery type : stork standalone stork in quarkus stork.my-service.service-discovery.type = consul quarkus.stork.my-service.service-discovery.type = consul Consul service discovery is configured with the following parameters: Service registration # Stork also provides the ability to register services using Consul as backend. Service registration configuration # For each service that should register the service instances in Consul, configure the service discovery type : stork standalone stork.my-service.service-registrar.type = consul stork in quarkus quarkus.stork.my-service.service-registrar.type = consul Consul service registrar is configured with the following parameters:","title":"Consul"},{"location":"service-discovery/consul/#consul-service-discovery","text":"Consul is a distributed, highly available, and data center aware solution to connect and configure applications across dynamic, distributed infrastructure. It\u2019s often used as service discovery backend to register and locate the services composing your system. Consul makes it simple for services to register themselves and to discover other services via a DNS or HTTP interface. External services can be registered as well. This page explains how Stork can use Consul to handle the service discovery and service registration.","title":"Consul Service Discovery"},{"location":"service-discovery/consul/#dependency","text":"First, you need to add the Stork Consul Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-consul </artifactId> <version> 1.4.1 </version> </dependency>","title":"Dependency"},{"location":"service-discovery/consul/#service-discovery-configuration","text":"For each service that should get the service instances from Consul, configure the service discovery type : stork standalone stork in quarkus stork.my-service.service-discovery.type = consul quarkus.stork.my-service.service-discovery.type = consul Consul service discovery is configured with the following parameters:","title":"Service discovery configuration"},{"location":"service-discovery/consul/#service-registration","text":"Stork also provides the ability to register services using Consul as backend.","title":"Service registration"},{"location":"service-discovery/consul/#service-registration-configuration","text":"For each service that should register the service instances in Consul, configure the service discovery type : stork standalone stork.my-service.service-registrar.type = consul stork in quarkus quarkus.stork.my-service.service-registrar.type = consul Consul service registrar is configured with the following parameters:","title":"Service registration configuration"},{"location":"service-discovery/custom-service-discovery/","text":"Implement your own service discovery mechanism # Stork is extensible, and you can implement your own service discovery mechanism. Dependencies # To implement your Service Discovery Provider , make sure your project depends on Core and Configuration Generator. The former brings classes necessary to implement custom discovery, the latter contains an annotation processor that generates classes needed by Stork. <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-core </artifactId> <version> 1.4.1 </version> </dependency> <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-configuration-generator </artifactId> <scope> provided </scope> <!-- provided scope is sufficient for the annotation processor --> <version> 1.4.1 </version> </dependency> Implementing a service discovery provider # Service discovery implementation consists of three elements: ServiceDiscovery which is responsible for locating service instances for a single Stork service. ServiceDiscoveryProvider which creates instances of ServiceDiscovery for a given service discovery type . $typeConfiguration which is a configuration for the discovery. This class is automatically generated during the compilation (using an annotation processor). A type , for example, acme , identifies each provider. This type is used in the configuration to reference the provider: stork standalone stork in quarkus stork.my-service.service-discovery.type = acme quarkus.stork.my-service.service-discovery.type = acme A ServiceDiscoveryProvider implementation needs to be annotated with @ServiceDiscoveryType that defines the type . Any configuration properties that the provider expects should be defined with @ServiceDiscoveryAttribute annotations placed on the provider. A service discovery provider class should look as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package examples ; import io.smallrye.stork.api.ServiceDiscovery ; import io.smallrye.stork.api.config.ServiceConfig ; import io.smallrye.stork.api.config.ServiceDiscoveryAttribute ; import io.smallrye.stork.api.config.ServiceDiscoveryType ; import io.smallrye.stork.spi.StorkInfrastructure ; import io.smallrye.stork.spi.ServiceDiscoveryProvider ; @ServiceDiscoveryType ( \"acme\" ) @ServiceDiscoveryAttribute ( name = \"host\" , description = \"Host name of the service discovery server.\" , required = true ) @ServiceDiscoveryAttribute ( name = \"port\" , description = \"Hort of the service discovery server.\" , required = false ) public class AcmeServiceDiscoveryProvider implements ServiceDiscoveryProvider < AcmeConfiguration > { @Override public ServiceDiscovery createServiceDiscovery ( AcmeConfiguration config , String serviceName , ServiceConfig serviceConfig , StorkInfrastructure storkInfrastructure ) { return new AcmeServiceDiscovery ( config ); } } Note, that the ServiceDiscoveryProvider interface takes a configuration class as a parameter. This configuration class is generated automatically by the Configuration Generator . Its name is created by appending Configuration to the service discovery type, such as AcmeConfiguration . The next step is to implement the ServiceDiscovery interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package examples ; import java.util.Collections ; import java.util.List ; import io.smallrye.mutiny.Uni ; import io.smallrye.stork.api.ServiceDiscovery ; import io.smallrye.stork.api.ServiceInstance ; import io.smallrye.stork.impl.DefaultServiceInstance ; import io.smallrye.stork.utils.ServiceInstanceIds ; public class AcmeServiceDiscovery implements ServiceDiscovery { private final String host ; private final int port ; public AcmeServiceDiscovery ( AcmeConfiguration configuration ) { this . host = configuration . getHost (); this . port = Integer . parseInt ( configuration . getPort ()); } @Override public Uni < List < ServiceInstance >> getServiceInstances () { // Proceed to the lookup... // Here, we just return a DefaultServiceInstance with the configured host and port // The last parameter specifies whether the communication with the instance should // happen over a secure connection DefaultServiceInstance instance = new DefaultServiceInstance ( ServiceInstanceIds . next (), host , port , false ); return Uni . createFrom (). item (() -> Collections . singletonList ( instance )); } } This implementation is simplistic. Typically, instead of creating a service instance with values from the configuration, you would connect to a service discovery backend, look for the service and build the list of service instance accordingly. That\u2019s why the method returns a Uni . Most of the time, the lookup is a remote operation. As you can see, the AcmeConfiguration class gives access to the configuration attribute. Using your service discovery # In the project using it, don\u2019t forget to add the dependency on the module providing your implementation. Then, in the configuration, just add: stork standalone stork in quarkus stork.my-service.service-discovery.type = acme stork.my-service.service-discovery.host = localhost stork.my-service.service-discovery.port = 1234 quarkus.stork.my-service.service-discovery.type = acme quarkus.stork.my-service.service-discovery.host = localhost quarkus.stork.my-service.service-discovery.port = 1234 Then, Stork will use your implementation to locate the my-service service. Using your service discovery using the programmatic API # When building your service discovery project, the configuration generator creates a configuration class. This class can be used to configure your service discovery using the Stork programmatic API. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import io.smallrye.mutiny.Uni ; import io.smallrye.stork.api.ServiceDefinition ; import io.smallrye.stork.api.ServiceInstance ; import io.smallrye.stork.api.StorkServiceRegistry ; public class AcmeDiscoveryApiUsage { public void example ( StorkServiceRegistry stork ) { stork . defineIfAbsent ( \"my-service\" , ServiceDefinition . of ( new AcmeConfiguration (). withHost ( \"my-host\" )) ); Uni < ServiceInstance > uni = stork . getService ( \"my-service\" ). selectInstance (); } } Remember that attributes, like host , are declared using the @ServiceDiscoveryAttribute annotation on the ServiceDiscoveryProvider implementation. Caching the service instances # Your ServiceDiscovery implementation can extend io.smallrye.stork.impl.CachingServiceDiscovery to automatically cache the service instances. In this case, the retrieved set of ServiceInstance is cached and only updated after some time. This duration is an additional configuration attribute. For homogeneity, we recommend the following attribute: @ServiceDiscoveryAttribute ( name = \"refresh-period\" , description = \"Service discovery cache refresh period.\" , defaultValue = CachingServiceDiscovery . DEFAULT_REFRESH_INTERVAL ) The following snippet extends the acme service discovery with the refresh-period attribute: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package examples ; import io.smallrye.stork.api.ServiceDiscovery ; import io.smallrye.stork.api.config.ServiceConfig ; import io.smallrye.stork.api.config.ServiceDiscoveryAttribute ; import io.smallrye.stork.api.config.ServiceDiscoveryType ; import io.smallrye.stork.impl.CachingServiceDiscovery ; import io.smallrye.stork.spi.ServiceDiscoveryProvider ; import io.smallrye.stork.spi.StorkInfrastructure ; @ServiceDiscoveryType ( \"cached-acme\" ) @ServiceDiscoveryAttribute ( name = \"host\" , description = \"Host name of the service discovery server.\" , required = true ) @ServiceDiscoveryAttribute ( name = \"port\" , description = \"Hort of the service discovery server.\" , required = false ) @ServiceDiscoveryAttribute ( name = \"refresh-period\" , description = \"Service discovery cache refresh period.\" , defaultValue = CachingServiceDiscovery . DEFAULT_REFRESH_INTERVAL ) public class CachedAcmeServiceDiscoveryProvider implements ServiceDiscoveryProvider < CachedAcmeConfiguration > { @Override public ServiceDiscovery createServiceDiscovery ( CachedAcmeConfiguration config , String serviceName , ServiceConfig serviceConfig , StorkInfrastructure storkInfrastructure ) { return new CachedAcmeServiceDiscovery ( config ); } } Extending io.smallrye.stork.impl.CachingServiceDiscovery changes the structure of the service discovery implementation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package examples ; import io.smallrye.mutiny.Uni ; import io.smallrye.stork.api.ServiceDiscovery ; import io.smallrye.stork.api.ServiceInstance ; import io.smallrye.stork.impl.CachingServiceDiscovery ; import io.smallrye.stork.impl.DefaultServiceInstance ; import io.smallrye.stork.utils.ServiceInstanceIds ; import java.util.Collections ; import java.util.List ; public class CachedAcmeServiceDiscovery extends CachingServiceDiscovery { private final String host ; private final int port ; public CachedAcmeServiceDiscovery ( CachedAcmeConfiguration configuration ) { super ( configuration . getRefreshPeriod ()); // (1) this . host = configuration . getHost (); this . port = Integer . parseInt ( configuration . getPort ()); } @Override // (2) public Uni < List < ServiceInstance >> fetchNewServiceInstances ( List < ServiceInstance > previousInstances ) { // Retrieve services... DefaultServiceInstance instance = new DefaultServiceInstance ( ServiceInstanceIds . next (), host , port , false ); return Uni . createFrom (). item (() -> Collections . singletonList ( instance )); } } Call the super constructor with the refresh-period value Implement fetchNewServiceInstances instead of getServiceInstances . The method is called periodically, and the retrieved instances are cached. This implementation is simplistic. If the retrieval fails, the error is reported, and Stork keeps the previously retrieved list of instances. Customizing the caching strategy # Sometimes it can be useful to change this behaviour and customize the cache expiration strategy. For example, imagine you are using a backend service discovery where service instances can change very frequently. Moreover, contacting the backend service discovery can be expensive in terms of computing, thus finding a good value for the refreshing time can be mission impossible. For these situations, Stork allows to implement a better expiration strategy for the cache. If you want to customize the expiration strategy, you need: 1. Implement the cache method where the expiration strategy should be defined. 2. Invalidate the cache when expiration condition evaluates to true. Take a look to the Kubernetes Service Discovery for further details about this feature.","title":"Custom Service Discovery"},{"location":"service-discovery/custom-service-discovery/#implement-your-own-service-discovery-mechanism","text":"Stork is extensible, and you can implement your own service discovery mechanism.","title":"Implement your own service discovery mechanism"},{"location":"service-discovery/custom-service-discovery/#dependencies","text":"To implement your Service Discovery Provider , make sure your project depends on Core and Configuration Generator. The former brings classes necessary to implement custom discovery, the latter contains an annotation processor that generates classes needed by Stork. <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-core </artifactId> <version> 1.4.1 </version> </dependency> <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-configuration-generator </artifactId> <scope> provided </scope> <!-- provided scope is sufficient for the annotation processor --> <version> 1.4.1 </version> </dependency>","title":"Dependencies"},{"location":"service-discovery/custom-service-discovery/#implementing-a-service-discovery-provider","text":"Service discovery implementation consists of three elements: ServiceDiscovery which is responsible for locating service instances for a single Stork service. ServiceDiscoveryProvider which creates instances of ServiceDiscovery for a given service discovery type . $typeConfiguration which is a configuration for the discovery. This class is automatically generated during the compilation (using an annotation processor). A type , for example, acme , identifies each provider. This type is used in the configuration to reference the provider: stork standalone stork in quarkus stork.my-service.service-discovery.type = acme quarkus.stork.my-service.service-discovery.type = acme A ServiceDiscoveryProvider implementation needs to be annotated with @ServiceDiscoveryType that defines the type . Any configuration properties that the provider expects should be defined with @ServiceDiscoveryAttribute annotations placed on the provider. A service discovery provider class should look as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package examples ; import io.smallrye.stork.api.ServiceDiscovery ; import io.smallrye.stork.api.config.ServiceConfig ; import io.smallrye.stork.api.config.ServiceDiscoveryAttribute ; import io.smallrye.stork.api.config.ServiceDiscoveryType ; import io.smallrye.stork.spi.StorkInfrastructure ; import io.smallrye.stork.spi.ServiceDiscoveryProvider ; @ServiceDiscoveryType ( \"acme\" ) @ServiceDiscoveryAttribute ( name = \"host\" , description = \"Host name of the service discovery server.\" , required = true ) @ServiceDiscoveryAttribute ( name = \"port\" , description = \"Hort of the service discovery server.\" , required = false ) public class AcmeServiceDiscoveryProvider implements ServiceDiscoveryProvider < AcmeConfiguration > { @Override public ServiceDiscovery createServiceDiscovery ( AcmeConfiguration config , String serviceName , ServiceConfig serviceConfig , StorkInfrastructure storkInfrastructure ) { return new AcmeServiceDiscovery ( config ); } } Note, that the ServiceDiscoveryProvider interface takes a configuration class as a parameter. This configuration class is generated automatically by the Configuration Generator . Its name is created by appending Configuration to the service discovery type, such as AcmeConfiguration . The next step is to implement the ServiceDiscovery interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package examples ; import java.util.Collections ; import java.util.List ; import io.smallrye.mutiny.Uni ; import io.smallrye.stork.api.ServiceDiscovery ; import io.smallrye.stork.api.ServiceInstance ; import io.smallrye.stork.impl.DefaultServiceInstance ; import io.smallrye.stork.utils.ServiceInstanceIds ; public class AcmeServiceDiscovery implements ServiceDiscovery { private final String host ; private final int port ; public AcmeServiceDiscovery ( AcmeConfiguration configuration ) { this . host = configuration . getHost (); this . port = Integer . parseInt ( configuration . getPort ()); } @Override public Uni < List < ServiceInstance >> getServiceInstances () { // Proceed to the lookup... // Here, we just return a DefaultServiceInstance with the configured host and port // The last parameter specifies whether the communication with the instance should // happen over a secure connection DefaultServiceInstance instance = new DefaultServiceInstance ( ServiceInstanceIds . next (), host , port , false ); return Uni . createFrom (). item (() -> Collections . singletonList ( instance )); } } This implementation is simplistic. Typically, instead of creating a service instance with values from the configuration, you would connect to a service discovery backend, look for the service and build the list of service instance accordingly. That\u2019s why the method returns a Uni . Most of the time, the lookup is a remote operation. As you can see, the AcmeConfiguration class gives access to the configuration attribute.","title":"Implementing a service discovery provider"},{"location":"service-discovery/custom-service-discovery/#using-your-service-discovery","text":"In the project using it, don\u2019t forget to add the dependency on the module providing your implementation. Then, in the configuration, just add: stork standalone stork in quarkus stork.my-service.service-discovery.type = acme stork.my-service.service-discovery.host = localhost stork.my-service.service-discovery.port = 1234 quarkus.stork.my-service.service-discovery.type = acme quarkus.stork.my-service.service-discovery.host = localhost quarkus.stork.my-service.service-discovery.port = 1234 Then, Stork will use your implementation to locate the my-service service.","title":"Using your service discovery"},{"location":"service-discovery/custom-service-discovery/#using-your-service-discovery-using-the-programmatic-api","text":"When building your service discovery project, the configuration generator creates a configuration class. This class can be used to configure your service discovery using the Stork programmatic API. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import io.smallrye.mutiny.Uni ; import io.smallrye.stork.api.ServiceDefinition ; import io.smallrye.stork.api.ServiceInstance ; import io.smallrye.stork.api.StorkServiceRegistry ; public class AcmeDiscoveryApiUsage { public void example ( StorkServiceRegistry stork ) { stork . defineIfAbsent ( \"my-service\" , ServiceDefinition . of ( new AcmeConfiguration (). withHost ( \"my-host\" )) ); Uni < ServiceInstance > uni = stork . getService ( \"my-service\" ). selectInstance (); } } Remember that attributes, like host , are declared using the @ServiceDiscoveryAttribute annotation on the ServiceDiscoveryProvider implementation.","title":"Using your service discovery using the programmatic API"},{"location":"service-discovery/custom-service-discovery/#caching-the-service-instances","text":"Your ServiceDiscovery implementation can extend io.smallrye.stork.impl.CachingServiceDiscovery to automatically cache the service instances. In this case, the retrieved set of ServiceInstance is cached and only updated after some time. This duration is an additional configuration attribute. For homogeneity, we recommend the following attribute: @ServiceDiscoveryAttribute ( name = \"refresh-period\" , description = \"Service discovery cache refresh period.\" , defaultValue = CachingServiceDiscovery . DEFAULT_REFRESH_INTERVAL ) The following snippet extends the acme service discovery with the refresh-period attribute: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package examples ; import io.smallrye.stork.api.ServiceDiscovery ; import io.smallrye.stork.api.config.ServiceConfig ; import io.smallrye.stork.api.config.ServiceDiscoveryAttribute ; import io.smallrye.stork.api.config.ServiceDiscoveryType ; import io.smallrye.stork.impl.CachingServiceDiscovery ; import io.smallrye.stork.spi.ServiceDiscoveryProvider ; import io.smallrye.stork.spi.StorkInfrastructure ; @ServiceDiscoveryType ( \"cached-acme\" ) @ServiceDiscoveryAttribute ( name = \"host\" , description = \"Host name of the service discovery server.\" , required = true ) @ServiceDiscoveryAttribute ( name = \"port\" , description = \"Hort of the service discovery server.\" , required = false ) @ServiceDiscoveryAttribute ( name = \"refresh-period\" , description = \"Service discovery cache refresh period.\" , defaultValue = CachingServiceDiscovery . DEFAULT_REFRESH_INTERVAL ) public class CachedAcmeServiceDiscoveryProvider implements ServiceDiscoveryProvider < CachedAcmeConfiguration > { @Override public ServiceDiscovery createServiceDiscovery ( CachedAcmeConfiguration config , String serviceName , ServiceConfig serviceConfig , StorkInfrastructure storkInfrastructure ) { return new CachedAcmeServiceDiscovery ( config ); } } Extending io.smallrye.stork.impl.CachingServiceDiscovery changes the structure of the service discovery implementation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package examples ; import io.smallrye.mutiny.Uni ; import io.smallrye.stork.api.ServiceDiscovery ; import io.smallrye.stork.api.ServiceInstance ; import io.smallrye.stork.impl.CachingServiceDiscovery ; import io.smallrye.stork.impl.DefaultServiceInstance ; import io.smallrye.stork.utils.ServiceInstanceIds ; import java.util.Collections ; import java.util.List ; public class CachedAcmeServiceDiscovery extends CachingServiceDiscovery { private final String host ; private final int port ; public CachedAcmeServiceDiscovery ( CachedAcmeConfiguration configuration ) { super ( configuration . getRefreshPeriod ()); // (1) this . host = configuration . getHost (); this . port = Integer . parseInt ( configuration . getPort ()); } @Override // (2) public Uni < List < ServiceInstance >> fetchNewServiceInstances ( List < ServiceInstance > previousInstances ) { // Retrieve services... DefaultServiceInstance instance = new DefaultServiceInstance ( ServiceInstanceIds . next (), host , port , false ); return Uni . createFrom (). item (() -> Collections . singletonList ( instance )); } } Call the super constructor with the refresh-period value Implement fetchNewServiceInstances instead of getServiceInstances . The method is called periodically, and the retrieved instances are cached. This implementation is simplistic. If the retrieval fails, the error is reported, and Stork keeps the previously retrieved list of instances.","title":"Caching the service instances"},{"location":"service-discovery/custom-service-discovery/#customizing-the-caching-strategy","text":"Sometimes it can be useful to change this behaviour and customize the cache expiration strategy. For example, imagine you are using a backend service discovery where service instances can change very frequently. Moreover, contacting the backend service discovery can be expensive in terms of computing, thus finding a good value for the refreshing time can be mission impossible. For these situations, Stork allows to implement a better expiration strategy for the cache. If you want to customize the expiration strategy, you need: 1. Implement the cache method where the expiration strategy should be defined. 2. Invalidate the cache when expiration condition evaluates to true. Take a look to the Kubernetes Service Discovery for further details about this feature.","title":"Customizing the caching strategy"},{"location":"service-discovery/dns/","text":"DNS Service Discovery # DNS is a name resolution protocol used to determine IP addresses for hostnames. That makes it a natural fit for service discovery. Consul and AWS Cloud Map provide DNS resolutions for service discovery. This page explains how Stork can use DNS to handle the service discovery. DNS records # DNS supports a variety of record types . Stork can resolve hostnames to addresses based on SRV , A and AAAA records. All these types of records may return multiple addresses for a single hostname. While A and AAAA records are quite similar, they just carry an IP ( v4 for A and v6 for AAAA ), the SRV records are different. They contain a weight , a target and a port for a service instance. The target returned in an SRV record needs to be resolved further by an A or an AAAA record. In short, it works as follows: Dependency # To use the DNS service discovery, you need to add the Stork DNS Service Discovery provider dependency to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-dns </artifactId> <version> 1.4.1 </version> </dependency> Configuration # Next, set the service discovery type to dns . Additionally, you would usually specify the DNS server, or servers, to use for the discovery. All in all, your configuration could look as follows: stork standalone stork in quarkus stork.my-service.service-discovery.type = dns # optional dns servers: stork.my-service.service-discovery.dns-servers = my-dns-server:8221,my-dns-server2 quarkus.stork.my-service.service-discovery.type = dns # optional dns servers: quarkus.stork.my-service.service-discovery.dns-servers = my-dns-server:8221,my-dns-server2 All the available parameters are as follows:","title":"DNS"},{"location":"service-discovery/dns/#dns-service-discovery","text":"DNS is a name resolution protocol used to determine IP addresses for hostnames. That makes it a natural fit for service discovery. Consul and AWS Cloud Map provide DNS resolutions for service discovery. This page explains how Stork can use DNS to handle the service discovery.","title":"DNS Service Discovery"},{"location":"service-discovery/dns/#dns-records","text":"DNS supports a variety of record types . Stork can resolve hostnames to addresses based on SRV , A and AAAA records. All these types of records may return multiple addresses for a single hostname. While A and AAAA records are quite similar, they just carry an IP ( v4 for A and v6 for AAAA ), the SRV records are different. They contain a weight , a target and a port for a service instance. The target returned in an SRV record needs to be resolved further by an A or an AAAA record. In short, it works as follows:","title":"DNS records"},{"location":"service-discovery/dns/#dependency","text":"To use the DNS service discovery, you need to add the Stork DNS Service Discovery provider dependency to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-dns </artifactId> <version> 1.4.1 </version> </dependency>","title":"Dependency"},{"location":"service-discovery/dns/#configuration","text":"Next, set the service discovery type to dns . Additionally, you would usually specify the DNS server, or servers, to use for the discovery. All in all, your configuration could look as follows: stork standalone stork in quarkus stork.my-service.service-discovery.type = dns # optional dns servers: stork.my-service.service-discovery.dns-servers = my-dns-server:8221,my-dns-server2 quarkus.stork.my-service.service-discovery.type = dns # optional dns servers: quarkus.stork.my-service.service-discovery.dns-servers = my-dns-server:8221,my-dns-server2 All the available parameters are as follows:","title":"Configuration"},{"location":"service-discovery/eureka/","text":"Eureka Service Discovery # Eureka is a RESTful service that is primarily used in the AWS cloud for the purpose of discovery, load balancing, and failover of middle-tier servers. This page explains how Stork can use Eureka to handle the service discovery and service registration. Dependency # First, you need to add the Stork Eureka Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-eureka </artifactId> <version> 1.4.1 </version> </dependency> Service discovery configuration # For each application instance expected to be registered in Eureka, configure the lookup: stork standalone stork in quarkus stork.my-service.service-discovery.type = eureka stork.my-service.service-discovery.eureka-host = localhost stork.my-service.service-discovery.eureka-port = 8761 quarkus.stork.my-service.service-discovery.type = eureka quarkus.stork.my-service.service-discovery.eureka-host = localhost quarkus.stork.my-service.service-discovery.eureka-port = 8761 Stork looks for the service with the given name ( my-service in the previous example). Supported attributes are the following: The application attribute is optional. It uses the Stork service name ( my-service in the previous configuration) if not set. The instance attribute allows selecting a specific instance. Using this attribute prevents load-balancing as you will always select a single instance. The secure attribute indicates if you want the secure virtual address of the application instance. If set to true , unsecured instances are filtered out from the available instances. Service registration # Stork also provides the ability to register services using Eureka as backend. Service registration configuration # For each service that should register the service instances in Eureka, configure the service discovery type : stork standalone stork.my-service.service-registrar.type = eureka stork.my-service.service-registrar.eureka-host = localhost stork.my-service.service-registrar.eureka-port = 8761 stork in quarkus quarkus.stork.my-service.service-registrar.type = eureka quarkus.stork.my-service.service-registrar.eureka-host = localhost quarkus.stork.my-service.service-registrar.eureka-port = 8761 Consul service registrar is configured with the following parameters:","title":"Eureka"},{"location":"service-discovery/eureka/#eureka-service-discovery","text":"Eureka is a RESTful service that is primarily used in the AWS cloud for the purpose of discovery, load balancing, and failover of middle-tier servers. This page explains how Stork can use Eureka to handle the service discovery and service registration.","title":"Eureka Service Discovery"},{"location":"service-discovery/eureka/#dependency","text":"First, you need to add the Stork Eureka Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-eureka </artifactId> <version> 1.4.1 </version> </dependency>","title":"Dependency"},{"location":"service-discovery/eureka/#service-discovery-configuration","text":"For each application instance expected to be registered in Eureka, configure the lookup: stork standalone stork in quarkus stork.my-service.service-discovery.type = eureka stork.my-service.service-discovery.eureka-host = localhost stork.my-service.service-discovery.eureka-port = 8761 quarkus.stork.my-service.service-discovery.type = eureka quarkus.stork.my-service.service-discovery.eureka-host = localhost quarkus.stork.my-service.service-discovery.eureka-port = 8761 Stork looks for the service with the given name ( my-service in the previous example). Supported attributes are the following: The application attribute is optional. It uses the Stork service name ( my-service in the previous configuration) if not set. The instance attribute allows selecting a specific instance. Using this attribute prevents load-balancing as you will always select a single instance. The secure attribute indicates if you want the secure virtual address of the application instance. If set to true , unsecured instances are filtered out from the available instances.","title":"Service discovery configuration"},{"location":"service-discovery/eureka/#service-registration","text":"Stork also provides the ability to register services using Eureka as backend.","title":"Service registration"},{"location":"service-discovery/eureka/#service-registration-configuration","text":"For each service that should register the service instances in Eureka, configure the service discovery type : stork standalone stork.my-service.service-registrar.type = eureka stork.my-service.service-registrar.eureka-host = localhost stork.my-service.service-registrar.eureka-port = 8761 stork in quarkus quarkus.stork.my-service.service-registrar.type = eureka quarkus.stork.my-service.service-registrar.eureka-host = localhost quarkus.stork.my-service.service-registrar.eureka-port = 8761 Consul service registrar is configured with the following parameters:","title":"Service registration configuration"},{"location":"service-discovery/knative/","text":"Knative Service Discovery # Knative is a Kubernetes-based platform for serverless workloads. Knative provides a set of objects as Kubernetes Custom Resource Definitions (CRDs). These resources are used to define and control how your serverless workload behaves on the cluster. The Stork Knative service discovery implementation is very similar to the Kubernetes one. Stork will ask for Knative services to the cluster instead of vanilla Kubernetes services used by the Kubernetes implementation. To do so, Stork uses Fabric 8 Knative Client which is just an extension of Fabric8 Kubernetes Client. Dependency # First, you need to add the Stork Knative Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-knative </artifactId> <version> 1.4.1 </version> </dependency> A few words about server authentication. # Stork uses Fabric8 Knative Client which is a Fabric8 Kubernetes Client extension to access the Kubernetes resources, concretely the DefaultKnativeClient implementation. Since Knative Client is just an extension of Fabric8 Kubernetes Client, it\u2019s also possible to get an instance of KnativeClient from KubernetesClient. DefaultKubernetesClient will try to read the ~/.kube/config file from your local machine and load the token for authenticating with the Kubernetes API server. The level of access (Roles) depends on the configured ServiceAccount . You can override this configuration if you want fine-grain control. Role-based access control (RBAC) # If you\u2019re using a Kubernetes cluster with Role-Based Access Control (RBAC) enabled, the default permissions for a ServiceAccount don\u2019t allow it to list or modify any resources. A ServiceAccount , a Role and a RoleBinding are needed in order to allow Stork to list the available service instances from the cluster or the namespace. An example that allows listing all endpoints could look something like this: ------ apiVersion : v1 kind : ServiceAccount metadata : name : <appname> namespace : <namespace> --- kind : Role apiVersion : rbac.authorization.k8s.io/v1 metadata : name : <appname> namespace : <namespace> rules : - apiGroups : [ \"\" ] # \"\" indicates the core API group resources : [ \"endpoints\" , \"pods\" ] # stork queries service endpoints and pods verbs : [ \"get\" , \"list\" ] --- apiVersion : rbac.authorization.k8s.io/v1beta1 kind : RoleBinding metadata : name : <appname> namespace : <namespace> subjects : - kind : ServiceAccount # Reference to upper's `metadata.name` name : <appname> # Reference to upper's `metadata.namespace` namespace : <namespace> roleRef : kind : Role name : <appname> apiGroup : rbac.authorization.k8s.io Configuration # For each service expected to be exposed as Kubernetes Service , configure the lookup: stork standalone stork in quarkus stork.my-knservice.service-discovery.type = knative stork.my-knservice.service-discovery.knative-namespace = my-namespace quarkus.stork.my-knservice.service-discovery.type = knative quarkus.stork.my-knservice.service-discovery.knative-namespace = my-namespace Stork looks for the Knative Service with the given name ( my-knservice in the previous example) in the specified namespace. Stork inspects the Knative Service and retrieves the url of the service. Supported attributes are the following: Caching the service instances # Contacting the cluster too much frequently can result in performance problems. It\u2019s why Knative Service discovery extends io.smallrye.stork.impl.CachingServiceDiscovery to automatically cache the service instances. Moreover, the caching expiration has been also improved in order to only update the retrieved set of ServiceInstance if some of them changes and an event is emitted. This is done by creating an Informer , similar to a Watch , able to observe the events on the Knative Service instances resources. Note that: - the cache is invalidated when an event is received. - the cache is validated once the instances are retrieved from the cluster, in the fetchNewServiceInstances method. - the cache method is overrided to customize the expiration strategy. In this case the collection of service instances will be kept until an event occurs.","title":"KNative"},{"location":"service-discovery/knative/#knative-service-discovery","text":"Knative is a Kubernetes-based platform for serverless workloads. Knative provides a set of objects as Kubernetes Custom Resource Definitions (CRDs). These resources are used to define and control how your serverless workload behaves on the cluster. The Stork Knative service discovery implementation is very similar to the Kubernetes one. Stork will ask for Knative services to the cluster instead of vanilla Kubernetes services used by the Kubernetes implementation. To do so, Stork uses Fabric 8 Knative Client which is just an extension of Fabric8 Kubernetes Client.","title":"Knative Service Discovery"},{"location":"service-discovery/knative/#dependency","text":"First, you need to add the Stork Knative Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-knative </artifactId> <version> 1.4.1 </version> </dependency>","title":"Dependency"},{"location":"service-discovery/knative/#a-few-words-about-server-authentication","text":"Stork uses Fabric8 Knative Client which is a Fabric8 Kubernetes Client extension to access the Kubernetes resources, concretely the DefaultKnativeClient implementation. Since Knative Client is just an extension of Fabric8 Kubernetes Client, it\u2019s also possible to get an instance of KnativeClient from KubernetesClient. DefaultKubernetesClient will try to read the ~/.kube/config file from your local machine and load the token for authenticating with the Kubernetes API server. The level of access (Roles) depends on the configured ServiceAccount . You can override this configuration if you want fine-grain control.","title":"A few words about server authentication."},{"location":"service-discovery/knative/#role-based-access-control-rbac","text":"If you\u2019re using a Kubernetes cluster with Role-Based Access Control (RBAC) enabled, the default permissions for a ServiceAccount don\u2019t allow it to list or modify any resources. A ServiceAccount , a Role and a RoleBinding are needed in order to allow Stork to list the available service instances from the cluster or the namespace. An example that allows listing all endpoints could look something like this: ------ apiVersion : v1 kind : ServiceAccount metadata : name : <appname> namespace : <namespace> --- kind : Role apiVersion : rbac.authorization.k8s.io/v1 metadata : name : <appname> namespace : <namespace> rules : - apiGroups : [ \"\" ] # \"\" indicates the core API group resources : [ \"endpoints\" , \"pods\" ] # stork queries service endpoints and pods verbs : [ \"get\" , \"list\" ] --- apiVersion : rbac.authorization.k8s.io/v1beta1 kind : RoleBinding metadata : name : <appname> namespace : <namespace> subjects : - kind : ServiceAccount # Reference to upper's `metadata.name` name : <appname> # Reference to upper's `metadata.namespace` namespace : <namespace> roleRef : kind : Role name : <appname> apiGroup : rbac.authorization.k8s.io","title":"Role-based access control (RBAC)"},{"location":"service-discovery/knative/#configuration","text":"For each service expected to be exposed as Kubernetes Service , configure the lookup: stork standalone stork in quarkus stork.my-knservice.service-discovery.type = knative stork.my-knservice.service-discovery.knative-namespace = my-namespace quarkus.stork.my-knservice.service-discovery.type = knative quarkus.stork.my-knservice.service-discovery.knative-namespace = my-namespace Stork looks for the Knative Service with the given name ( my-knservice in the previous example) in the specified namespace. Stork inspects the Knative Service and retrieves the url of the service. Supported attributes are the following:","title":"Configuration"},{"location":"service-discovery/knative/#caching-the-service-instances","text":"Contacting the cluster too much frequently can result in performance problems. It\u2019s why Knative Service discovery extends io.smallrye.stork.impl.CachingServiceDiscovery to automatically cache the service instances. Moreover, the caching expiration has been also improved in order to only update the retrieved set of ServiceInstance if some of them changes and an event is emitted. This is done by creating an Informer , similar to a Watch , able to observe the events on the Knative Service instances resources. Note that: - the cache is invalidated when an event is received. - the cache is validated once the instances are retrieved from the cluster, in the fetchNewServiceInstances method. - the cache method is overrided to customize the expiration strategy. In this case the collection of service instances will be kept until an event occurs.","title":"Caching the service instances"},{"location":"service-discovery/kubernetes/","text":"Kubernetes Service Discovery # Kubernetes has a built-in support for service discovery and load-balancing. However, you may need more flexibility to carefully select the service instance you want. This page explains how Stork can use the Kubernetes API to handle the service discovery. Dependency # First, you need to add the Stork Kubernetes Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-kubernetes </artifactId> <version> 1.4.1 </version> </dependency> A few words about server authentication. # Stork uses Fabric8 Kubernetes Client to access the Kubernetes resources, concretely the DefaultKubernetesClient implementation. It will try to read the ~/.kube/config file from your local machine and load the token for authenticating with the Kubernetes API server. If you are using the Stork Kubernetes discovery provider from inside a Pod , it loads ~/.kube/config from the container file system. This file is automatically mounted inside the Pod. The level of access (Roles) depends on the configured ServiceAccount . You can override this configuration if you want fine-grain control. Role-based access control (RBAC) # If you\u2019re using a Kubernetes cluster with Role-Based Access Control (RBAC) enabled, the default permissions for a ServiceAccount don\u2019t allow it to list or modify any resources. A ServiceAccount , a Role and a RoleBinding are needed in order to allow Stork to list the available service instances from the cluster or the namespace. An example that allows listing all endpoints could look something like this: ------ apiVersion : v1 kind : ServiceAccount metadata : name : <appname> namespace : <namespace> --- kind : Role apiVersion : rbac.authorization.k8s.io/v1 metadata : name : <appname> namespace : <namespace> rules : - apiGroups : [ \"\" ] # \"\" indicates the core API group resources : [ \"endpoints\" , \"pods\" ] # stork queries service endpoints and pods verbs : [ \"get\" , \"list\" ] --- apiVersion : rbac.authorization.k8s.io/v1beta1 kind : RoleBinding metadata : name : <appname> namespace : <namespace> subjects : - kind : ServiceAccount # Reference to upper's `metadata.name` name : <appname> # Reference to upper's `metadata.namespace` namespace : <namespace> roleRef : kind : Role name : <appname> apiGroup : rbac.authorization.k8s.io Configuration # For each service expected to be exposed as Kubernetes Service , configure the lookup: stork standalone stork in quarkus stork.my-service.service-discovery.type = kubernetes stork.my-service.service-discovery.k8s-namespace = my-namespace quarkus.stork.my-service.service-discovery.type = kubernetes quarkus.stork.my-service.service-discovery.k8s-namespace = my-namespace Stork looks for the Kubernetes Service with the given name ( my-service in the previous example) in the specified namespace. Instead of using the Kubernetes Service IP directly, and let Kubernetes handle the selection and balancing, Stork inspects the service and retrieves the list of pods providing the service. Then, it can select the instance. Supported attributes are the following: Caching the service instances # Contacting the cluster too much frequently can result in performance problems. It\u2019s why Kubernetes Service discovery extends io.smallrye.stork.impl.CachingServiceDiscovery to automatically cache the service instances. Moreover, the caching expiration has been also improved in order to only update the retrieved set of ServiceInstance if some of them changes and an event is emitted. This is done by creating an Informer , similar to a Watch , able to observe the events on the service instances resources. Note that: - the cache is invalidated when an event is received. - the cache is validated once the instances are retrieved from the cluster, in the fetchNewServiceInstances method. - the cache method is overrided to customize the expiration strategy. In this case the collection of service instances will be kept until an event occurs.","title":"Kubernetes"},{"location":"service-discovery/kubernetes/#kubernetes-service-discovery","text":"Kubernetes has a built-in support for service discovery and load-balancing. However, you may need more flexibility to carefully select the service instance you want. This page explains how Stork can use the Kubernetes API to handle the service discovery.","title":"Kubernetes Service Discovery"},{"location":"service-discovery/kubernetes/#dependency","text":"First, you need to add the Stork Kubernetes Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-kubernetes </artifactId> <version> 1.4.1 </version> </dependency>","title":"Dependency"},{"location":"service-discovery/kubernetes/#a-few-words-about-server-authentication","text":"Stork uses Fabric8 Kubernetes Client to access the Kubernetes resources, concretely the DefaultKubernetesClient implementation. It will try to read the ~/.kube/config file from your local machine and load the token for authenticating with the Kubernetes API server. If you are using the Stork Kubernetes discovery provider from inside a Pod , it loads ~/.kube/config from the container file system. This file is automatically mounted inside the Pod. The level of access (Roles) depends on the configured ServiceAccount . You can override this configuration if you want fine-grain control.","title":"A few words about server authentication."},{"location":"service-discovery/kubernetes/#role-based-access-control-rbac","text":"If you\u2019re using a Kubernetes cluster with Role-Based Access Control (RBAC) enabled, the default permissions for a ServiceAccount don\u2019t allow it to list or modify any resources. A ServiceAccount , a Role and a RoleBinding are needed in order to allow Stork to list the available service instances from the cluster or the namespace. An example that allows listing all endpoints could look something like this: ------ apiVersion : v1 kind : ServiceAccount metadata : name : <appname> namespace : <namespace> --- kind : Role apiVersion : rbac.authorization.k8s.io/v1 metadata : name : <appname> namespace : <namespace> rules : - apiGroups : [ \"\" ] # \"\" indicates the core API group resources : [ \"endpoints\" , \"pods\" ] # stork queries service endpoints and pods verbs : [ \"get\" , \"list\" ] --- apiVersion : rbac.authorization.k8s.io/v1beta1 kind : RoleBinding metadata : name : <appname> namespace : <namespace> subjects : - kind : ServiceAccount # Reference to upper's `metadata.name` name : <appname> # Reference to upper's `metadata.namespace` namespace : <namespace> roleRef : kind : Role name : <appname> apiGroup : rbac.authorization.k8s.io","title":"Role-based access control (RBAC)"},{"location":"service-discovery/kubernetes/#configuration","text":"For each service expected to be exposed as Kubernetes Service , configure the lookup: stork standalone stork in quarkus stork.my-service.service-discovery.type = kubernetes stork.my-service.service-discovery.k8s-namespace = my-namespace quarkus.stork.my-service.service-discovery.type = kubernetes quarkus.stork.my-service.service-discovery.k8s-namespace = my-namespace Stork looks for the Kubernetes Service with the given name ( my-service in the previous example) in the specified namespace. Instead of using the Kubernetes Service IP directly, and let Kubernetes handle the selection and balancing, Stork inspects the service and retrieves the list of pods providing the service. Then, it can select the instance. Supported attributes are the following:","title":"Configuration"},{"location":"service-discovery/kubernetes/#caching-the-service-instances","text":"Contacting the cluster too much frequently can result in performance problems. It\u2019s why Kubernetes Service discovery extends io.smallrye.stork.impl.CachingServiceDiscovery to automatically cache the service instances. Moreover, the caching expiration has been also improved in order to only update the retrieved set of ServiceInstance if some of them changes and an event is emitted. This is done by creating an Informer , similar to a Watch , able to observe the events on the service instances resources. Note that: - the cache is invalidated when an event is received. - the cache is validated once the instances are retrieved from the cluster, in the fetchNewServiceInstances method. - the cache method is overrided to customize the expiration strategy. In this case the collection of service instances will be kept until an event occurs.","title":"Caching the service instances"},{"location":"service-discovery/static-list/","text":"Static List Service Discovery # In some situations, such as demos, development, or testing, you may want to mock the service discovery by providing a predefined list of service instances. For this purpose, Stork comes with a static service discovery type. Dependency # To use the static service discovery, first add the appropriate Service Discovery provider dependency to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-static-list </artifactId> <version> 1.4.1 </version> </dependency> Configuration # For each service that should use the static list of service instances configure the service discovery type : stork standalone stork in quarkus stork.my-service.service-discovery.type = static stork.my-service.service-discovery.address-list = localhost:8080,localhost:8081 quarkus.stork.my-service.service-discovery.type = static quarkus.stork.my-service.service-discovery.address-list = localhost:8080,localhost:8081 These are all the static service discovery parameters:","title":"Static List"},{"location":"service-discovery/static-list/#static-list-service-discovery","text":"In some situations, such as demos, development, or testing, you may want to mock the service discovery by providing a predefined list of service instances. For this purpose, Stork comes with a static service discovery type.","title":"Static List Service Discovery"},{"location":"service-discovery/static-list/#dependency","text":"To use the static service discovery, first add the appropriate Service Discovery provider dependency to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> stork-service-discovery-static-list </artifactId> <version> 1.4.1 </version> </dependency>","title":"Dependency"},{"location":"service-discovery/static-list/#configuration","text":"For each service that should use the static list of service instances configure the service discovery type : stork standalone stork in quarkus stork.my-service.service-discovery.type = static stork.my-service.service-discovery.address-list = localhost:8080,localhost:8081 quarkus.stork.my-service.service-discovery.type = static quarkus.stork.my-service.service-discovery.address-list = localhost:8080,localhost:8081 These are all the static service discovery parameters:","title":"Configuration"}]}